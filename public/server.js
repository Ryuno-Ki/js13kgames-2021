/**
 * This file is part of JS13kGames - SPACE.
 * Lido Space is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * Lido Space is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with Lido Space.  If not, see <https://www.gnu.org/licenses/>.
 */

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});function t(t){const e=t.length;return t[Math.floor(Math.random()*e)]}function e(e,o){let n=e.games;switch(o.mode){case"new":n=function(t,e){return[].concat(t.games).concat({host:e.id,opponents:[],spectators:[]})}(e,o);break;case"join":n=function(e,o){const n=t(e.games.filter((t=>Boolean(t.host))).filter((t=>t.opponents.length<4)));return e.games.map((t=>t.host===n.host?{...t,opponents:[].concat(t.opponents).concat(o.id)}:t))}(e,o);break;case"watch":n=function(e,o){const n=t(e.games.filter((t=>Boolean(t.host))).filter((t=>t.opponents.length>0)));return e.games.map((t=>t.host===n.host?{...t,spectators:[].concat(t.spectators).concat(o.id)}:t))}(e,o)}const s=e.modes.map((t=>t.id===o.id?{...o}:t));return Object.assign({},e,{games:n,modes:s})}const o={connections:[],games:[],modes:[],users:[]};const n=new class{constructor(t){this.reducer=t,this.state=t(void 0,{type:""})}getState(){return this.state}dispatch(t){this.state=this.reducer(this.state,t)}}((function(t,n){if(void 0===t)return o;switch(n.type){case"ADD_NAME":return function(t,e){const o=[].concat(t.modes).concat({id:e.id,mode:null}),n=[].concat(t.users).concat(e);return Object.assign({},t,{modes:o,users:n})}(t,n.payload);case"CONNECT":return function(t,e){const o=[].concat(t.connections).concat(e.id);return Object.assign({},t,{connections:o})}(t,n.payload);case"DISCONNECT":return function(t,e){const o=t.connections.filter((t=>t!==e.id)),n=t.games.filter((t=>t.host!==e.id)).map((t=>({...t,opponents:t.opponents.filter((t=>t!==e.id))}))).map((t=>({...t,spectators:t.spectators.filter((t=>t!==e.id))}))),s=t.users.filter((t=>t.id!==e.id)),c=t.users.filter((t=>t.id!==e.id));return Object.assign({},t,{connections:o,games:n,modes:s,users:c})}(t,n.payload);case"REMOVE_USER":return function(t,e){const{id:o}=e,n=t.users.filter((t=>t.id!==o));return Object.assign({},t,{users:n})}(t,n.payload);case"SELECT_MODE":return e(t,n.payload);case"UPDATE_NAME":return function(t,e){const{id:o,name:n}=e,s=t.users.map((t=>t.id===o?{...t,name:n}:t));return Object.assign({},t,{users:s})}(t,n.payload);default:return t}}));class s{constructor(t){this.socket=t,this.game=null,this.opponents=[],this.role=ROLE_UNKNOWN}setRole(t){this.role=t}start(t,e){this.game=t,this.opponents=e,this.socket.emit("start",{role:this.role,opponents:this.opponents.length,spectators:0})}end(){this.game=null,this.opponents=[],this.role=ROLE_UNKNOWN,this.socket.emit("end")}win(){this.opponents.forEach((t=>{this.socket.emit("win")}))}loose(){this.opponents.forEach((t=>{this.socket.emit("loose")}))}draw(){this.opponents.forEach((t=>{this.socket.emit("draw")}))}}const c=function(t){const e=`${t}:`;return{debug:console.log.bind(console,e),log:console.log.bind(console,e),info:console.info.bind(console,e),warn:console.warn.bind(console,e),error:console.error.bind(console,e)}}("io");exports.io=function(t){const e=new s(t);n.dispatch({type:"CONNECT",payload:{id:t.id}}),t.on("disconnect",(()=>function(t,e){c.info(`Disconnected: ${t.id}`),n.dispatch(function(t){return{type:"DISCONNECT",payload:{id:t}}}(t.id))}(t))),t.on("addUser",(e=>{n.dispatch(function(t,e){return{type:"ADD_NAME",payload:{id:t,name:e}}}(t.id,e.name)),c.debug("State",n.getState())})),t.on("selectMode",(e=>{n.dispatch(function(t,e){return{type:"SELECT_MODE",payload:{id:t,mode:e}}}(t.id,e.mode)),c.debug("State",n.getState())})),t.on("keyUp",(t=>{!async function(t,e,o){try{await async function(){const t=storage.get("games",0);await storage.set("games",t+1)}()}catch(t){console.error(t)}e.opponents.forEach((t=>{t.socket.emit("sync",o)}))}(0,e,t)})),c.info(`Connected: ${t.id}`)},exports.stat=async function(t,e){const o=await storage.get("games",0);e.send(`<h1>Games played: ${o}</h1>`)};
