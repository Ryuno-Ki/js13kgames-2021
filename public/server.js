/**
 * This file is part of JS13kGames - SPACE.
 * Lido Space is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * Lido Space is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with Lido Space.  If not, see <https://www.gnu.org/licenses/>.
 */

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});function t(t){const n=`${t}:`;return{debug:console.log.bind(console,n),log:console.log.bind(console,n),info:console.info.bind(console,n),warn:console.warn.bind(console,n),error:console.error.bind(console,n)}}function n(t){return t*Math.PI/180}function e(t,n){return{type:"ADD_NAME",payload:{id:t,name:n}}}function o(t,n){return{type:"ADD_POINT",payload:{id:t,point:n}}}function s(t,n){return{type:"JOIN_GAME",payload:{id:t,host:n}}}function i(t,n){return{type:"SELECT_MODE",payload:{id:t,mode:n}}}function a(t,n){let e=t.games,o=t.points;switch(n.mode){case"new":e=function(t,n){return[].concat(t.games).concat({host:n.id,opponents:[],spectators:[]})}(t,n),o=function(t,n){return[].concat(t.points).concat({id:n.id,x:160,y:100})}(t,n);break;case"join":o=function(t,n){let e=0;if(n.id.startsWith("AI-")){const t=/\d+/.exec(n.id);t&&(e=parseInt(t[0],10)%4)}const o=[{x:0,y:100},{x:320,y:100},{x:160,y:0},{x:160,y:200}][e];return[].concat(t.points).concat({id:n.id,...o})}(t,n);break;case"watch":e=function(t,n){const e=function(t){const n=t.length;return t[Math.floor(Math.random()*n)]}(t.games.filter((t=>Boolean(t.host))).filter((t=>t.opponents.length>0)));return t.games.map((t=>t.host===e.host?{...t,spectators:[].concat(t.spectators).concat(n.id)}:t))}(t,n)}const s=t.modes.map((t=>t.id===n.id?{...n}:t));return Object.assign({},t,{games:e,modes:s,points:o})}const c={colors:[],connections:[],games:[],modes:[],points:[],scenes:[],users:[]};const r=t("store");const d=new class{constructor(t){this.reducer=t,this.state=t(void 0,{type:""})}dispatch(t){this.state=this.reducer(this.state,t),r.debug(`Dispatched ${JSON.stringify(t)}.\nNew state: ${JSON.stringify(this.state)}`)}findGameAvailableForJoin(){const t=this.state.games.find((t=>!!t.opponents.find((t=>t.startsWith("AI-")))));return t||null}getGameForHost(t){const n=this._findGameBySocketId(t);if(!n)return null;const e=this.state.colors.find((t=>t.id===n.host));return{host:{color:e?e.value:"transparent",name:this._resolveNameForId(n.host)},opponents:n.opponents.map((t=>{const n=this.state.colors.find((n=>n.id===t));return{color:n?n.value:"transparent",name:this._resolveNameForId(t)}})),spectators:n.spectators}}getPointsForHost(t){const n=this._findGameBySocketId(t);return n?this.state.points.filter((t=>t.id===n.host)).map((t=>[t.x,t.y])).slice(-13):[]}getOpponentIdsOfHost(t){const n=this._findGameBySocketId(t);return n?n.opponents:[]}getPointsForOpponents(t){const n=this._findGameBySocketId(t);if(!n)return[];return n.opponents.map((t=>this.state.points.filter((n=>n.id===t)).map((t=>[t.x,t.y]))))}getPointsForOpponent(t){if(!this._findGameBySocketId(t))return[];return this.state.points.filter((n=>n.id===t)).map((t=>[t.x,t.y]))}getState(){return this.state}_findGameBySocketId(t){return this.state.games.find((n=>!(n.host!==t)||!!n.opponents.includes(t)))||null}_resolveNameForId(t){const n=this.state.users.find((n=>n.id===t));return n?n.name:null}}((function(t,n){if(void 0===t)return c;switch(n.type){case"ADD_NAME":return function(t,n){const e=`hsl(${Math.floor(360*Math.random())}, 80%, 50%)`,o=[].concat(t.colors).concat({id:n.id,value:e}),s=[].concat(t.modes).concat({id:n.id,mode:null}),i=[].concat(t.users).concat(n);return Object.assign({},t,{colors:o,modes:s,users:i})}(t,n.payload);case"ADD_POINT":return function(t,n){const e={id:n.id,...n.point},o=[].concat(t.points).concat(e);return Object.assign({},t,{points:o})}(t,n.payload);case"CONNECT":return function(t,n){const e=[].concat(t.connections).concat(n.id),o=[].concat(t.scenes).concat({id:n.id,scene:"title"});return Object.assign({},t,{connections:e,scenes:o})}(t,n.payload);case"DISCONNECT":return function(t,n){const e=t.colors.filter((t=>t.id!==n.id)),o=t.connections.filter((t=>t!==n.id)),s=t.games.filter((t=>t.host!==n.id)).map((t=>({...t,opponents:t.opponents.filter((t=>t!==n.id))}))).map((t=>({...t,spectators:t.spectators.filter((t=>t!==n.id))}))),i=t.modes.filter((t=>t.id!==n.id)),a=t.points.filter((t=>t.id!==n.id)),c=t.scenes.filter((t=>t.id!==n.id)),r=t.users.filter((t=>t.id!==n.id));return Object.assign({},t,{colors:e,connections:o,games:s,modes:i,points:a,scenes:c,users:r})}(t,n.payload);case"JOIN_GAME":return function(t,n){const e=t.games.map((t=>t.host===n.host?{...t,opponents:[].concat(t.opponents).concat(n.id)}:t));return Object.assign({},t,{games:e})}(t,n.payload);case"NAVIGATE":return function(t,n){const e=t.scenes.map((t=>t.id===n.id?{...n}:t));return Object.assign({},t,{scenes:e})}(t,n.payload);case"REMOVE_USER":return function(t,n){const{id:e}=n,o=t.users.filter((t=>t.id!==e));return Object.assign({},t,{users:o})}(t,n.payload);case"SELECT_MODE":return a(t,n.payload);case"SWAP_USER":return function(t,n){const e=t.games.map((t=>({...t,opponents:t.opponents.map((t=>t===n.replacedId?n.id:t))}))),o=t.modes.map((t=>t.id===n.replacedId?{id:t.id,mode:null}:t)),s=t.points.map((t=>t.id===n.replacedId?{...t,id:n.id}:t));return Object.assign({},t,{games:e,modes:o,points:s})}(t,n.payload);case"UPDATE_NAME":return function(t,n){const{id:e,name:o}=n,s=t.users.map((t=>t.id===e?{...t,name:o}:t));return Object.assign({},t,{users:s})}(t,n.payload);default:return t}})),p={x:160,y:100},l=t("io"),u={};let f=0;function m(t){const n=d.getOpponentIdsOfHost(t);u[t].emit("sync",{role:ROLE_HOST,points:d.getPointsForHost(t)}),n.forEach((n=>{u[t].emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(n)})})),n.map((t=>u[t])).filter(Boolean).forEach((e=>{e.emit("sync",{role:ROLE_HOST,points:d.getPointsForHost(t)}),n.forEach((t=>{e.emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(t)})}))}))}exports.io=function(t){d.dispatch({type:"CONNECT",payload:{id:t.id}}),u[t.id]=t,t.on("disconnect",(()=>function(t){l.info(`Disconnected: ${t.id}`),d.dispatch(function(t){return{type:"DISCONNECT",payload:{id:t}}}(t.id))}(t))),t.on("addUser",(n=>{d.dispatch(e(t.id,n.name))})),t.on("navigate",(n=>{d.dispatch(function(t,n){return{type:"NAVIGATE",payload:{id:t,scene:n}}}(t.id,n.scene))})),t.on("selectMode",(n=>{let o;switch(d.dispatch(i(t.id,n.mode)),n.mode){case"new":!function(t){for(let n=0;n<3;n++){const n=`AI-${f}`;d.dispatch(e(n,`Bot No. ${f}`)),d.dispatch(i(n,"join")),d.dispatch(s(n,t)),f+=1}}(t.id),t.emit("start",{role:ROLE_HOST,...d.getGameForHost(t.id)}),m(t.id);break;case"join":o=d.findGameAvailableForJoin(),o&&(d.dispatch(function(t,n){return{type:"SWAP_USER",payload:{id:t,replacedId:n}}}(t.id,o.opponents.find((t=>t.startsWith("AI-"))))),t.emit("start",{role:ROLE_OPPONENT,...d.getPointsForOpponents(t.id)}),m(t.id))}})),t.on("keyUp",(e=>{e.delta?(d.dispatch(o(t.id,function(t){const e=130,o=13,{x:s,y:i}=function({radius:t,angle:n}){return{x:t*Math.cos(n),y:t*Math.sin(n)}}({radius:e*Math.random(),angle:n(360*t/o)});return{x:Math.floor(p.x+s),y:Math.floor(p.y+i)}}(e.delta))),d.dispatch(o(t.id,{...p})),m(t.id)):e.direction&&(d.dispatch(o(t.id,function(t,n){let e=0,o=0;const s=d.getPointsForOpponent(t),[i,a]=s[s.length-1];switch(n){case 2:a+20<=200&&(o=20);break;case 3:i-32>=0&&(e=-32);break;case 1:i+32<=320&&(e=32);break;case 0:a-20>=0&&(o=-20)}return{x:i+e,y:a+o}}(t.id,e.direction))),t.emit("sync",{role:ROLE_OPPONENT,points:d.getPointsForOpponents(t.id)}))})),l.info(`Connected: ${t.id}`)},exports.stat=async function(t,n){const e=await storage.get("games",0);n.send(`<h1>Games played: ${e}</h1>`)};
